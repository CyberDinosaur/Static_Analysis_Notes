# 模糊测试Fuzzing

## 简介

软件漏洞分析的代表性技术

从漏洞分析的角度，Fuzzing是一种通过`构造非预期`的输入数据并监视目标软件在运行过程中的异常结果来发现软件故障的方法。

<img src=".\Pic\12.01.jpg" style="zoom:80%;" />

用于模糊测试的模糊测试器（fuzzer）分为两类：

- 一类是基于变异的模糊测试器，它通过对已有的数据样本进行变异来创建测试用例
- 另一类是基于生成的模糊测试器，它为被测试系统使用的协议或文件格式建模，基于模型生成输入并据此创建测试用例。

## 原理

根据概率论里面的“大数定律”，只要我们`重复的次数够多、随机性够强`，那些概率极低的偶然事件就必然会出现。Fuzzing技术就是大数定律的典范应用，足够多的测试用例和随机性，就可以让那些隐藏的很深很难出现的Bug成为必然现象。

## 模糊测试流程

模糊测试通常包含下面几个基本阶段：

1. **确定测试目标**：确定目标程序的性质、功能、运行条件和环境、编写程序的语言、软件过去所发现的漏洞信息以及与外部进行交互的接口等

2. **确定输入向量**：例如文件数据、网络数据和环境变量等。

   未能定位可能的输入源或预期的输入值对模糊测试将产生严重的影响，因此枚举输入向量对模糊测试的成功至关重要。因此输入目标程序的任何输入都应该被认为是输入向量，都应该是可能的模糊测试变量。

3. **生成模糊测试数据**：在确定输入向量之后设计要模糊测试的方法和测试数据生成算法等(也即在利用现有数据以及测试目标的结构的基础上，变异已有的数据或者动态构建输入数据)

4. **执行模糊测试数据**：自动完成向测试目标发送大量测试数据的过程，包括启动目标进程、发送测试数据和打开文件等

5. **监视异常**：监视目标程序是否产生异常，记录使程序产生异常的测试数据和异常相关信息。

   这个步骤也可以和构建数据阶段形成一个反馈回路。

6. **判定发现的漏洞是否可被利用**：通过将产生异常的数据重新发送给目标程序，跟踪异常产生前后程序相关的处理流程，分析异常产生的原因，从而判断是否可利用。这个步骤一般是一个人工过程。

## 基本要求

要实现高效的模糊测试，通常需要满足下面几个方面的要求：

1. **可重现性**：测试者必须能够知道使目标程序状态变化所对应的测试数据是什么，如果不具备重现测试结果的能力，那么整个过程就失去了意义。实现可重现性的一个方法是在发送测试数据的同时记录下测试数据和目标程序的状态
2. **可重用性**：进行模块化开发，这样就不需要为一个新的目标程序重新开发一个模糊测试器
3. **代码覆盖**：指模糊测试器能够使目标程序达到或执行的所有代码及过程状态的数量
4. **异常监视**：能够精确地判定目标程序是否发生异常非常的关键。

## 优缺点

**优点**

* 测试成本低

* 技术门槛相对低

* 目前漏洞挖掘常用的有效方式

**缺点**

* 测试用例冗余度大：由于很多测试用例通过随机策略产生，导致会产生重复或相似的测试用例

* 对关联字段的针对性不强：大多数时候只是对多个元素进行数据的随机生成或变异，缺乏对协议关联字段的针对性

## 方法实现

### 输入数据的关联分析

应用程序的输入数据通常都遵循一定的规范，并具有固定的结构。例如：网络数据包通常遵守某种特定的网络协议规范，文件数据通常遵守特定的文件格式规范。通常情况下，应用程序都会对输入的数据对象进行`格式检查`，格式检查失败则会直接退出处理流程。

通过分析输入到程序的`数据对象的结构`以及其`组成元素之间的依赖关系`，构造符合格式要求的测试用例绕过程序格式检查，是提高模糊测试成功率的重要步骤。也即生成的测试输入数据不能异想天开，而要满足格式要求。

而现实中应用程序所能处理的`数据对象是非常复杂的`。例如 MS Office 文件是一种基于对象嵌入和链接方式存储的复合文件，不仅可以在文件中嵌入其他格式的文件，还可以包含多种不同类型的元数据。这种复杂性导致在对其进行模糊测试的过程中产生的绝大多数测试数据都不能被应用程序所接受。因此，我们需要一种能描述模糊测试中复杂数据对象的模型。

`数据块关联模型`是解决这一问题的有效途径。该模型以数据块为基本元素，以数据块之间的关联性为纽带生成畸形测试数据。其中，数据块是数据块关联模型的基础。通常一个数据对象可以分为几个数据块，数据块之间的依赖关系称为数据关联。

**数据块的划分：**

- 使数据块之间的关联性尽可能的小
- 将具有特定意义的数据划分为一个数据块
- 将一段连续且固定不变的数据划分为同一个数据块

**数据块关联模型：**

- **关联方式**

  - 内关联：指同一数据对象内不同数据块之间的关联性。

    > 长度关联：数据对象内某一个或几个数据块表示另一数据块的长度。是文件格式、网络协议和ActiveX控件模糊测试中最常见的一种数据关联方式。

    <img src=".\Pic\12.02.jpg" style="zoom:80%;" />

  - 外关联：指属于多个不同数据对象的多个不同数据块之间存在的关联性。

    > 内容关联：某个数据对象的某个数据块表示另一个（或同一个）数据对象的另一个数据块的值。在需要用户验证的网络协议应用中经常出现。

    <img src=".\Pic\12.03.jpg" style="zoom:80%;" />

- **关联强度**

  定义关联强度 $S = \frac{\sum R_i}{\sum B_i}$，也即关联数据块的数量占总数据块数量的比重。$S$ 越大表示数据块之间的关联越强，使用模糊测试构造测试数据的过程也就越复杂。

  - 强关联：关联数据块的数量 ≥ 非关联数据块的数量。也即$S \ge \frac 12$
  - 弱关联：关联数据块的数量 ＜ 非关联数据块的数量。也即$S \lt \frac 12$

  特别的，$S = 0$ 表示各数据块之间是独立无关的；$S = 1$ 表示各数据块之间都是存在关联的。

- **评价标准**

  对于一款模糊测试工具，评价其好坏除了依据其已经发现的漏洞外，还有另一个重要的评价标准：

  - 有效数据对象效率 $V$：构造的畸形数据对象个数与能够被应用程序所接受处理的数据对象个数的比率，也即模糊测试器生成的测试对象能够被程序所接受的比率是多少，表示其生成的测试对象有多少是符合应用程序输入格式要求的。
    $$
    V = \frac {\sum P_V}{\sum P_i}
    $$

  例如：FTP数据包格式，每个包都以”\r\n”作为结束标记。如果模糊测试工具构造的数据包为”USERAAAAA\n” 以”\n”为结束标记，那么该数据包是不能够被FTP识别和处理的，属于无效数据包。

  一般来说，有效数据对象效率 $V$ 与关联度 $S$ 成反比。

### 测试用例集的构建方法

![](.\Pic\12.04.jpg)

### 测试异常分析

获取程序的某些运行时信息（尤其是异常发生时的运行时信息），然后对记录下来的信息中我们感兴趣的部分进行重点分析，从而提高漏洞挖掘效率：

<img src=".\Pic\12.05.jpg" style="zoom:90%;" />

### 模糊测试框架

模糊测试框架是一个通用的模糊器，可以对不同类型的目标进行模糊测试，它将一些单调的工作抽象化，并且将这些工作减少到最低程度。通常模糊测试框架都包含以下几个部分：

<img src=".\Pic\12.06.jpg" style="zoom:80%;" />



# 符号执行Symbolic Execution

<img src=".\Pic\12.07.jpg" style="zoom:70%;" />

## 静态符号执行

符号的关键思想就在于，使用抽象的符号代替具体的值，这样每个程序的输出值就可以表征为输入符号集的一个函数。由于程序的离散特性，这个“函数”我们又可以抽象为一个执行树，其包含了程序运行中可能出现的所有路径，符号执行实际上就是生成对应的输入集合，以求能够在给定的时间内探索执行树上所有的路径。

<img src="C:\Users\84222\Desktop\Static Analysis\Pic\12.08.jpg" style="zoom:80%;" />

**符号状态σ（symbolic state）**：记录变量到符号表达式的映射

**符号路径约束 PC（path condition）**：符号表示的不含量词的一阶表达式，也即由符号构成的一阶谓词表达式表征路径。

$\sigma$ 被初始化为空映射，PC被初始化为true(实际上表征执行树的根节点一定可达，也即程序可以正常进入)，两者随着符号执行的过程被不断更新：

* **遇到一个读语句var=sym_input()**：即接收程序输入，符号执行就会在符号状态 $\sigma$ 中加入一条映射 $var \rightarrow s$ 其中 $s$ 就是一个未被约束的新符号值。在上面的代码中，main函数的前两行会得到结果 $\sigma = \{ x \rightarrow x_0, y \rightarrow y_0\}$，其中 $x_0$ 与 $y_0$ 就是两个没有被约束的初始化符号值，其没有被约束表征在此时，为了探索对应的路径，约束求解器可以给对应的符号分配任何实值。

* **遇到一个赋值语句v=e**：需要更新符号状态 $\sigma$，加入变量 $v \rightarrow \sigma(e)$ 的映射，其中 $\sigma(e)$ 表示在当前符号化状态下计算表达式e所得到的结果。例如，在上图中代码执行完第6行时，$\sigma = \{ x \rightarrow x_0, y \rightarrow y_0, z \rightarrow 2y_0\}$。

* **遇到条件语句if(e) S1 else S2**：由于会产生两条可能的路径，因此PC增加两条约束对应不同的路径。例如，第7行建立了两个符号执行实例，路径约束分别是 $x_0 = 2y_0$ 和 $x_0 \ne 2y_0$。在第8行，又建立了两个符号执行实例，路径约束分别是 $(x_0=2y_0) \and (x_0 > y_0+10)$ 和 $(x_0=2y_0) \and (x_0 \le y_0+10)$。

* **遇到了exit语句或者错误（程序崩溃、违反断言等）**：符号执行的当前实例会终止，利用`约束求解器`对当前符号路径约束赋一个可满足的值，而可满足的赋值就构成了测试输入：如果程序执行这些实际输入值，就会在同样的路径结束。例如，上面程序在进行符号执行后会产生三个符号执行实例，对应三个不同的符号路径约束，对其进行求解会得到三个不同的测试输入 $\{x=0, y=1\}, \{x=2, y=1\}, \{x=30, y=15\}$

* 如果符号执行的代码包含**循环或递归**，且它们的终止条件是符号化的，那么可能就会导致产生无数条路径。每条路径的可能性有两种：

  * 要么是任意数量的true加上一个false结尾 

    $\left( \bigwedge\limits_{i \in [1,n]} N_i>0 \right) \and (N_{n+1} \le 0)$ 

  * 要么是无穷多数量的true

  其实这就是符号执行面临的问题之一，即如何处理循环中的无限多路径。在实际中，有一些方法可以应对，比如对搜索加入限制，要么是限制搜索时间的长短，要么是限制路径数量、循环迭代次数、探索深度等等。

  符号执行面临的另一个问题就是，如果符合执行路径的符号路径约束难以使用约束求解器进行有效的求解，则无法生成输入。比如如下的函数（或者更变态一点，函数的源码可能都不知道）：

  <img src=".\Pic\12.10.jpg" style="zoom:80%;" />

## 动态符号执行

上面讨论的符号执行都是静态符号执行，其面临无穷递归和约束难以求解(可能是形成了复杂条件，也可能是约束条件中包含系统调用等约束求解器访问不到的函数)两个问题。动态符号执行Concolic Execution就解决了上面的约束难以求解的问题。其混合真实执行与符号执行，在约束求解无法进行的时候，使用真实值代替符号值。

动态符号执行主要用于生成测试输入

* Concolic Testing, Koushik Sen

  主要工具：CUTE

* Execution-Generated Testing, Cristian Cadar

  主要工具：KLEE

其本质上是一个深度优先探索的过程，先顺着某条路径一路到底进行类似静态符号执行的过程，在路径结束时(EXIT)，在执行树上回退一步并探索相反的路径（对路径约束上的某个条件取反）。而且在探索某条路径时，需要维护真实执行和符号执行两种状态，其中真实执行的初始值随机产生，或者产生于上一次探索的路径约束结果取反后求解得到的值；也即符号执行结束得到的路径约束结果取反后送给约束求解器求解，得到的结果就是相反路径真实执行的初始值（同时也是此路径的测试输入），对于求解器难以处理的部分，直接用实际值进行替换即可。

使用实际值，可以让因外部代码交互和约束求解超时造成的不精确大大降低，但付出的代价就是，会有丢失路径的缺陷，牺牲了路径探索的完全性。

> 参考：https://zhuanlan.zhihu.com/p/26927127